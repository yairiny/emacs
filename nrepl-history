;; -*- coding: utf-8-unix -*-
;; Automatically written history of nREPL session
;; Edit at your own risk

("(pprint (generate-world 4 3))" "(pprint (generate-world))" "(pprint generate-world)" "(pprint (create-maze 4 3))" "(pprint *1)" "(create-maze 4 3)" "(pprint (cut-maze test-world))" "(pprint (cut-maze test-world 4 3))" "(pprint *1)" "(cut-maze test-world 4 3)" "(pprint test-world)" "(def test-world (start-maze-world 4 3 [0 0]))" "(def test-world (start-maze-world [4 3 [0 0]]))" "(apply position [2 3])" "(make-tile :floor (position 0 1))" "(pprint (get-tile test-tiles 1 0))" "(pprint *1)" "(get-tile test-tiles 0 0)" "(def test-tiles (create-single-arch-tile-array (:wall all-tile-archetypes) 3 2))" "(get-tile test-tiles 0 0)" "(pprint test-tiles)" "(def test-tiles (create-single-arch-tile-array (:wall all-tile-archetypes) 3 2))" "test-tiles" "(get-tile test-tiles 0 0)" "(def test-tiles (create-single-arch-tile-array (:wall all-tile-archetypes) 3 2))" "(pprint (create-single-arch-tile-array (:wall all-tile-archetypes) 3 2))" "(partition 3 (range 6))" "(pprint *1)" "(create-single-arch-tile-array (:wall all-tile-archetypes) 3 2)" "(pprint *1)" "(create-single-arch-tile-array (:wall all-tile-archetypes) 3 2)" "(pprint *1)" "(use 'clojure.pprint)" "(pprint *1)" "(create-single-arch-tile-array (:wall all-tile-archetypes) 3 2)" "(for [x (range 2) y (range 3)] [x y])" "(assoc-in [] [0 0] :a)" "(assoc-in [] [0] :a)" "(assoc-in [] [1] :a)" "*clojure-version*" "(r/fold + [1 2 3 4])" "(+)" "(as-> [] myv (conj myv 1) (mapv (partial * 2) myv))" "(as-> [] myv (conj myv 1))" "(as-> [] myv)" "(as-> [] myv (conj myv 1) (mapv (partial *2) myv))" "(doc as->)" "as->" "->as" "(runme)" "(defn runme [] (main :swing true))" "(defn runme (main :swing true))" "(main :swing true)" "(change-location [159 48] [1 1])" "(change-location [159 49] [1 1])" "(change-location [0 0] [-1 1])" "(change-location [0 0] [-1 -1])" "(change-location [2 4] [-1 -1])" "(let [[x y] *1] (println x y))" "(map dec world-size)" "(main :swing true)" "(map - [4 5] [2 1])" "(quot 12 2)" "(quot 11 2)" "(quot 10 2)" "(doc rem)" "(use 'clojure.repl)" "(doc rem)" "(rem 9 2)" "(div 9 2)" "(main :swing true)" "(def g3 (process-input g2 \\s))" "(process-input g2 \\s)" "(get-in g2 [:world :exposed])" "(keys (:world g2))" "(process-input g2 \\s)" "(:uis g2)" "(keys (:world g2))" "(keys g2)" "(type g2)" "(def g2 (process-input g :enter))" "g" "(keys (:world g))" "(keys g)" "(def g (new-game))" "(main :swing true)" "(float (/ 4830 (* 160 50)))" "(map count (vals w))" "(map count (keys w))" "(keys w)" "(type w)" "(def w *1)" "(generate-world 160 50)" "(generate-world)" "(->World)" "(merge w {:a 1})" "w" "(merge w {:a 1})" "w" "(def w (->World nil))" "(def w (->World))" "(repeatedly 4 #(rand-int 10))" "(repeatedly #(rand-int 10) 4)" "(take 10 (constantly 4))" "(repeat 3 5)" "(map #(* % %) (range 5))" "(dotimes [i 5] (println i))" "(dotimes [i 5])" "(main :swing true)" "(def g (generate-world 4 3))" "(generate-world 4 3)" "(main :swing true)" "(get-tile tiles 0 0)" "(type (get-tile tiles 0 0))" "(type tiles)" "(count tiles)" "(def tiles (:tiles (create-maze 160 50)))" "(pprint *1)" "(create-maze 3 4)" "(pprint maze)" "(pprint (cut-maze 3 4 maze))" "(pprint maze2)" "(def maze2 (cut-maze 3 4 maze))" "(pprint maze2)" "(def maze2 (cut-maze 3 4 maze))" "(clojure.set/difference #{1 2 3} #{2 4})" "(pprint maze2)" "(def maze2 (cut-maze 3 4 maze))" "(pprint maze2)" "(def maze2 (cut-maze 3 4 maze))" "(pprint maze)" "(def maze (start-maze-world 3 4 [0 0]))" "(def maze2 (cut-maze 3 4 maze))" "maze2" "(def maze2 (cut-maze 3 4 maze))" "maze2" "(def maze2 (cut-maze 3 4 maze))" "(pprint maze)" "maze" "(clojure.set/intersection #{1 2} #{2 3})" "(clojure.set/join #{1 2} #{2 3})" "(clojure.set/union #{1 2} #{2 3})" "(disj #{1 2 3} 2)" "(pprint maze)" "(def maze (start-maze-world 3 4 [0 0]))" "(pprint maze)" "(def maze (start-maze-world 3 4 [0 0]))" "(pprint maze)" "(def maze (start-maze-world 3 4 [0 0]))" "(pprint maze)" "(def maze (start-maze-world 3 4 [0 0]))" "(pprint *1)" "(assoc-in maze [0 0] (:floor all-tiles))" "(pprint maze)" "maze" "(def maze (start-maze-world 3 4 [0 0]))" "(pprint *1)" "(start-maze-world 3 4 [0 0])" "(start-maze-world 3 4)" "(repeat  2 5)" "(repeat 5 2)" "(get-potential-exposed-square [9 8] 10 10)" "(get-potential-exposed-square 9 8 10 10)" "(get-potential-exposed-square 9 10 10 10)" "(get-potential-exposed-square 9 9 10 10)" "(get-potential-exposed-square 1 1 10 10)" "(get-potential-exposed-square 0 0 10 10)" "#{1 2 nil}" "(vec (concat [] nil nil [4]))" "(vec (concat [] nil nil 4))" "(vec (concat [] nil))" "(concatv [] nil)" "(concat [] nil)" "(conj [] [])" "(conj [] nil)" "(main :swing true)" "(draw-ui (first (:uis g)) g nil)" "(draw-game g nil)" "(:uis g)" "(keys g)" "(:kind g)" "(let [{:keys [glyph]} (w/get-tile tiles 0 0)] glyph)" "(w/get-tile tiles 0 0)" "(get-tile tiles 0 0)" "(type tiles)" "(def tiles (get-in g [:world :tiles]))" "(get-in g [:world :tiles])" "(map type (vals g))" "(keys g)" "g" "(def g (process-input g :enter))" "g" "(def g (new-game))" "(main :swing true)" "(range 2 (+ 2 3))" "(range 2 3)" "(w/get-tile tiles 2 3)" "(get-tile tiles 2 3)" "(get-in tiles 2 3)" "(type tiles)" "(def tiles (get-in g [:world :tiles]))" "(def g (new-game))" "(get-in tiles [3 4])" "(count (first tiles))" "(count (tiles 0))" "(count tiles)" "(take 3 tiles)" "(class tiles)" "(def tiles (get-in g [:world :tiles]))" "(def g (new-game))" "(process-input g \\c)" "(process-input g :backspace)" "(process-input g :enter)" "g" "(def g (->Game [] [(->UI :play)] nil))" "(def g (->Game [] [(->UI :play) nil]))" "(keys g)" "(def g (new-game))" "(new-game)" "(generate-world 2 3)" "(pprint (generate-world 3 5))" "(println (generate-world 3 5))" "(pprint (generate-world 3 5))" "(pprint (generate-world 0 5))" "(pprint (generate-world 0 0))" "(use 'clojure.pprint)" "(generate-world 10 10)" "(generate-world)" "(get-tile nil 0 0)" "(:bound tiles)" "(get-tile nil 0 0)" "(get-in nil [0 1] 8)" "(get-in [] [0 1] 8)" "(get-in [0] [0 1] 8)" "(get-in [[0]] [0 1] 8)" "(get-in [[0]] [0 0] 8)" "(get-in [[0]] [0 0])" "(get-in [0] [0])" "(get-in [[\\x]] 0 0)" "(get-in nil 0 0)" "(System/exit 0)" "tf" "(def tf (temp-file \"yair\"))" "(use 'me.raynes.fs)" "(use 'fs.core)" "(parse-file \"SCATS_1.xml\")" "(get-ts-now)" "(parse-file \"SCATS_1.xml\")" "(test-tx)" "(parse-file \"SCATS_1.xml\")" "database" "(parse-file \"SCATS_1.xml\")" "resource" "(doc resource)" "(create-insertion \"test1\")" "(parse-file \"SCATS_1.xml\")" "(count *1)" "(parse-file \"SCATS_1.xml\")" "(count *1)" "(parse-file \"SCATS_1.xml\")" "(resource \"files/SCATS_1.xml\")" "(parse-file \"SCATS_1.xml\")" "(System/exit 0)" "(System/exit)" "(create-user-record :email \"email\" :password \"password\" :first-name \"first\" :last-name \"last\" :middle-names \"M1 M2\" :client-id 1 :user-type :client)" "(create-user-record :email \"email\" :password \"password\" :first-name \"first\" :last-name \"last\" :middle-names [] :client-id 1 :user-type :client)" "(clojure.string/join \" \" [\"1\" \"2\"])" "(clojure.string/join [\"1\" \"2\"] \" \")" "(clojure.string/join [1 2 3] \" \")" "(create-user-record :email \"email\" :password \"password\" :first-name \"first\" :last-name \"last\" :middle-names [] :client-id 1 :user-type :client)" "(create-user-record :email \"yair.iny@gmail.com\" :password \"password\" :first-name \"Yair\" :last-name \"Iny\" :middle-names [\"Jacob\" \"Isaac\"] :client-id 1 :user-type :client)" "(k/dry-run (create-user-record :email \"yair.iny@gmail.com\" :password \"password\" :first-name \"Yair\" :last-name \"Iny\" :middle-names [\"Jacob\" \"Isaac\"] :client-id 1 :user-type :client))" "(create-user-record :email \"yair.iny@gmail.com\" :password \"password\" :first-name \"Yair\" :last-name \"Iny\" :middle-names [\"Jacob\" \"Isaac\"] :client-id 1 :user-type :client)" "(does-user-exist? \"yair.iny@gmail.com\")" "(does-user-exist? 7)" "(nil? \"h\")" "(does-user-exist? \"yair.iny@gmail.com\")" "(string? \"7\")" "(string? 7)" "(cr/compare \"Hello\" *1)" "(cr/encrypt \"Hello\")" "(cr/compare *1 \"Hello\")" "(cr/encrypt \"Hello\")" "(dry-run (select users (where {:client-id 6})))" "(select users (where {:client-id 6}))" "(get :smtp :port)" "(get :smtp :url)" "(get :domain-id)" "(dry-run (select users (with clients (where {:id 5}))))" "(dry-run (select users (with clients)))" "(select users (with clients))" "(select users)" "(dry-run (select users))" " (println ())" "(println (+ 2 (* 4 5)))" "(stop-app)" "(start-app)" "(stop-app)" "(start-app)" "(stop-app)" "(start-app)" "(System/exit 0)" "(.exit @the-app)" "(.stop @the-app)" "@the-app" "the-app" "(start-app)" "@the-app" "(stop-app)" "(start-app)" "(my-main)" "Gdx/gl" "(Gdx/gl)" "(Gdx.gl/glClearColor)" "(Gdx$gl/glClearColor)" "(my-main)" "ApplicationListener")
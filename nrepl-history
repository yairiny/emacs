;; -*- coding: utf-8-unix -*-
;; Automatically written history of nREPL session
;; Edit at your own risk

("(+ 1 1)" "(check-if-payer-exists \"PAYR2\" \"BVRNTU00103\")" "(check-if-payer-exists \"PAYR2\" \"BVRNTU00102\")" "(check-if-payer-exists \"PAYRQ\" \"BVRNTU001023\")" "(check-if-payer-exists \"PAYRQ\" \"BVRNTU00102\")" "(k/dry-run (check-if-payer-exists))" "(check-if-payer-exists \"PAYRQ\" \"BVRNTU00102\")" "(k/select db/biller-payer)" "(check-if-payer-exists \"PAYRQ\" \"BVRNTU00102\")" "(check-if-payer-exists \"PAYRQ\" 2002)" "(get-actor-system-for-registration \"PAYRQ\")" "(initialise)" "(str \"UUID/\" (java.util.UUID/randomUUID))" "(str (java.util.UUID/randomUUID))" "(java.util.UUID/randomUUID)" "(payreq.registration/process-payer-registrations)" "(initialise)" "(pprint (macroexpand-1 '(schedule-job process-registrations \"scsdas\")))" "(pprint (macroexpand-1 '(schedule-job read-incoming \"scsdas\")))" "(shutdown)" "(initialise)" "(pprint (macroexpand-1 '(schedule-job read-incoming \"scsdas\")))" "(use 'clojure.pprint)" "(pprint *1)" "(macroexpand-1 '(schedule-job read-incoming \"scsdas\"))" "(macroexpand-1 '(schedule-job read-incoming))" "(macroexpand-1)" "(name 'process-payer-registrations)" "(name process-payer-registrations)" "(process-payer-registrations)" "(update-activation-status reg-rec :processed)" "(k/dry-run (update-activation-status reg-rec :processed))" "(def reg-rec (first *1))" "(find-unprocessed-registrations)" "(process-payer-registrations)" "(map? *1)" "(get-actor-system-for-registration \"PAYRQ\")" "(handle-single-registration (first (process-payer-registrations)))" "(pr-str {:as 1})" "(handle-single-registration (first (process-payer-registrations)))" "(bip/find-contact-by-bvrn bctx \"BVRNTU00101\")" "bctx" "(def bctx (bi/create-context-for-registration binfo))" "(pprint binfo)" "(use 'clojure.pprint)" "binfo" "(def binfo (get-actor-system-for-registration \"PAYRQ\"))" "(handle-single-registration (first (process-payer-registrations)))" "(*1 nil nil)" "(resolve 'payreq.billing-interface.saasu/generate-name-from-contact)" "(handle-single-registration (first (process-payer-registrations)))" "(process-payer-registrations)" "(use 'clojure.tools.trace)" "(handle-single-registration (first (process-payer-registrations)))" "(handle-single-registration rec)" "(pprint rec)" "(pprint *1)" "(get-actor-system-for-registration \"PAYRQ\")" "(handle-single-registration rec)" "rec" "(create-payer {} {} {:name-account-held \"Yair Iny\" :payer-id \"12345678\"})" "(create-tag nil nil)" "(handle-single-registration rec)" "(def rec (first (process-payer-registrations)))" "(handle-single-registration rec)" "(pprint rec)" "(def rec (first (process-payer-registrations)))" "(reduce #(and %1 %2) [true true true])" "(reduce and [true true true])" "(handle-single-registration rec)" "(pprint rec)" "(def rec (first (process-payer-registrations)))" "(handle-single-registration rec)" "(def rec (first (process-payer-registrations)))" "(def rec (first process-payer-registrations))" "(handle-single-registration rec)" "(pprint rec)" "(use 'clojure.pprint)" "(pprint rec)" "rec" "(sort (select-keys tbinfo [:bpv-auth-item-1-field :bpv-auth-item-2-field :bpv-auth-item-3-field]))" "(sort first *1)" "(select-keys tbinfo [:bpv-auth-item-1-field :bpv-auth-item-2-field :bpv-auth-item-3-field])" "(select-keys :bpv-auth-item-1-field :bpv-auth-item-2-field :bpv-auth-item-3-field)" "tbinfo" "(def tbinfo (get-actor-system-for-registration \"PAYRQ\"))" "(handle-single-registration rec)" "rec" "(def rec (first (process-payer-registrations)))" "(def rec (first *1))" "(process-payer-registrations)" "(k/dry-run (process-payer-registrations))" "(dry-run (process-payer-registrations))" "(process-payer-registrations)" "(update-contact-by-bvrn ctx \"BVRNTU00101\" {:email \"dog.cats@hello.com\"})" "(find-contact-by-bvrn ctx \"BVRNTU00101\")" "ctx" "(verify-task-response-success s1)" "s1" "(def s1 \"<tasksResponse> 
    <updateContactResult updatedEntityUid=\\\"24001\\\" LastUpdatedUid=\\\"A37CA998\\\" />
    <insertInvoiceResult insertedEntityUid=\\\"253501\\\" LastUpdatedUid=\\\"78273DA=\\\" sentToContact=\\\"true\\\" />
  </tasksResponse>\")" "(update-contact-by-bvrn ctx \"BVRNTU00101\" {:email \"yinyBBB@icm.com\"})" "(find-contact-by-bvrn ctx \"BVRNTU00101\")" "(pprint ctx)" "(def ctx (create-context-for-registration \"PAYRQ\"))" "(pprint *1)" "(create-context-for-registration \"PAYRQ\")" "(:system-id *1)" "(get-actor-system-for-registration \"PAYRQ\")" "(select actor-system (where {:bpv-check-payer-cred true}) (with customer-actor (where {:bpv-biller-id \"PAYRQ\"})))" "(dry-run (select actor-system (where {:bpv-check-payer-cred true}) (with customer-actor (where {:bpv-biller-id \"PAYRQ\"}))))" "(dry-run (select actor-system (where {:bpv-check-payer-cred true}) (with customer-actor)))" "(select actor-system (where {:bpv-check-payer-cred true}))" "(dry-run (select actor-system (where {:bpv-check-payer-cred true})))" "(dry-run (select actor-system))" "(.getHostName (java.net.InetAddress/getLocalHost))" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yiny@icm-consulting.com.au\"})" "(find-contact-by-bvrn nil \"BVRNTU00101\")" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yinyA@icm.com\"})" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yiny7@icm.com\"})" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yiny4@icm.com\"})" "(find-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yiny4@icm.com\"})" "(find-contact-by-bvrn nil \"BVRNTU00101\")" "(pprint *1)" "(find-contact-by-bvrn nil \"BVRNTU00101\")" "(use 'clojure.pprint)" "((comp str first) [1 2])" "((comp first str) [1 2])" "((comp (first str)) [1 2])" "((comp (str first)) [1 2])" "(comp (str first) [1 2])" "(comp (first str) [1 2])" "(saasu-contact-list-query nil \"BVRNTU00101\")" "(deref *1)" "(future (+ 1 4))" "@(future (+ 1 1))" "(resolve *1)" "(future (+ 1 1))" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:email \"yyy@yair.com\"})" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:emailAddress \"yyy@yair.com\"})" "@*1" "(update-contact-by-bvrn nil \"BVRNTU00101\" {:emailAddress \"yyy@yair.com\"})" "(xml/emit-str (xml/element :yair {} (map-to-xml {:a \"1\" :b \"2\"})))" "(xml/emit-str (map-to-xml {:a \"1\" :b \"2\"}))" "(map-to-xml {:a \"1\" :b \"2\"})" "(map-to-xml {:a 1 :b 2})" "(xml/emit-str (xml/element :yair {} (map-to-xml {:a 1 :b 2})))" "(xml/element :yair {} (map-to-xml {:a 1 :b 2}))" "(xml/element :yair (map-to-xml {:a 1 :b 2}))" "(xml/emit-str (xml/element :yair (map-to-xml {:a 1 :b 2})))" "(xml/emit-str :yair (map-to-xml {:a 1 :b 2}))" "(map-to-xml {:a 1 :b 2})" "(xml/emit-str (xml/element :yair))" "(xml/element :yair)" "(xml/emit-str {:tag :yair})" "(xml/emit-str *1)" "(map-to-xml {:a 1 :b 2})" "(:lastUpdatedUid *1)" "(find-contact-by-bvrn nil \"BVRNTU00101\")" "(find-contact-by-bvrn nil \"BVRNTU00101s\")" "(pprint (find-contact-by-bvrn nil \"BVRNTU00101s\"))" "(empty? {})" "(pprint (find-contact-by-bvrn nil \"BVRNTU00101s\"))" "(pprint (find-contact-by-bvrn nil \"BVRNTU00101\"))" "(pprint (find-contact-by-bvrn nil \"asdsad\"))" "(pprint rsp)" "(def rsp (find-contact-by-bvrn nil \"asdsa\"))" "(pprint rsp)" "(use 'clojure.pprint)" "(def rsp (find-contact-by-bvrn nil \"asdsa\"))" "(get-in rsp [:content])" "(get-in rsp [:content 0])" "(:tag rsp)" "rsp" "(def rsp (find-contact-by-bvrn nil \"asdsa\"))" "rsp" "(def rsp (find-contact-by-bvrn nil \"asdsa\"))" "(type *1)" "(find-contact-by-bvrn nil \"asdsa\")" "(build-saasu-url \"a\" \"b\" \"c\" \"ContactID\" \"Yair\")" "(build-saasu-url \"a\" \"b\" \"c\")" "(build-saasu-url \"a\" \"b\" \"c\" \"ContactID\" \"Yair\")" "(empty? \"\")" "(build-saasu-url \"a\" \"b\" \"c\" \"ContactID\" \"Yair\")" "(build-saasu-url \"a\" \"b\" \"c\")" "(clojure.string/join \":\" [1 2 3])" "(clojure.string/join [1 2 3] \":\")" "(map println {:a 1 :b 2})" "(find-contact-by-bvrn :saasu \"BVRNTU00101\")" "(find-contact-by-bvrn nil nil)" "(dry-run (select bpv-file))" "(select bpv-file)" "(do-incoming-file-process)" "(get-cfg :bpv-interface :directories :sent)" "(get-cfg :bpv-interface :directories)" "(get-cfg :bpv-interfaces :directories)" "(get-cfg :bpv-interfaces :directoroes)" "(error \"Hello\")" "(use 'clojure.tools.logging)" "(dummy-do)" "(parse-registration-line-count-line registration-line-count-bad-too-short)" "(dummy-do)" "(parse-registration-file-line registration-line-count-good)" "(dummy-do)" "(error \"Hello\")" "(use 'clojure.tools.logging)" "(error \"Hello\")" "(use 'clojure.tools.logging)" "(error \"Hello\")" "(use 'clojure.tools.logging)" "(dummy-do)" "(make-ack-name \"yair.csvs\")" "(make-ack-name \"yair.csv\")" "(clojure.string/split \"yair.csv\" #\".csv\")" "(clojure.string/split \"yair.csv\" #\"\\\\.csv\")" "(clojure.string/split \"yair.csv\" #\".csv\")" "(clojure.string/split \"yair.csv\" \"\\\\.csv\")" "(clojure.string/split \"yair.csv\" \"\\.csv\")" "(require 'clojure.string)" "(.endsWith \"yair.csv\" \".csv\")" "(.endsWith \".csv\" \"yair.csv\")" "(.getParentFile (second fs))" "(.getName (second fs))" "fs" "(def fs (file-seq (io/file \"/Users/yair/temp/payreq/incoming\")))" "(create-ack-file {:bsp-user-id \"BSPUSERID\" :transaction-id \"TXID\" :file-type-number \"BLA\" :interface-spec-version \"1.0\" :data-generated-datetime dt} \"1001\" \"Yair was here\")" "(create-ack-file {:bsp-user-id \"BSPUSERID\" :transaction-id \"TXID\" :file-type-number \"BLA\" :interface-spec-version \"1.0\" :data-generated-datetime dt} \"1001\" nil)" "(create-ack-file {:bsp-user-id \"BSPUSERID\" :transaction-id \"TXID\" :file-type-number \"BLA\" :interface-spec-version \"1.0\" :data-generated-datetime dt})" "(unparse-bpv-dt dt)" "dt" "(def dt (parse-bpv-dt \"21031105121314\"))" "(def dt (unparse-bpv-dt \"21031105121314\"))" "(create-ack-file {:bsp-user-id \"BSPUSERID\" :transaction-id \"TXID\" :file-type-number \"BLA\" :interface-spec-version \"1.0\" data-generated-datetime nil})" "(dummy-do)" "(select bpv-file)" "(test1)" "(select bpv-file)" "(test1)" "(dry-run (test1))" "(test1)" "(insert testme (values {:name \"Oren\"}))" "(dummy-do)" "(number? \"y\")" "(use)" "(require 'payreq.config)" "(doc meta)" "(meta base-config)" "base-config" "(doc bases)" "(use ['clojure.repl :only ['doc]
                     ])" "(use ['clojure.repl :only [doc]
                     ])" "(doc bases)" "bases" "base-config" "(base-config)" "(handle-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(csv/parse-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(handle-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(clojure.java.io/resource \"test-bpv-files/single-registration.csv\")" "(str (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(handle-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "()" "(parse-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(pprint (parse-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\")))" "(use ['clojure.pprint :only ['pprint]])" "(use ['clojure.pprint :only [pprint]])" "(use '(clojure.pprint :only [pprint]))" "(use 'clojure.pprint)" "(pprint *1)" "(parse-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(parse-file (clojure.java.io/resource \"test-bpv-files\"))" "(last [1 2 3])" "(butlast [1 2 3])" "(apply-rule \"3\" (activation-line-rules 0))" "(apply-rule \"2\" (activation-line-rules 0))" "(apply-rule \"1\" (activation-line-rules 0))" "(apply-rule [\"1\"] (activation-line-rules 0))" "((one-of \"Yair\" \"Oren\") \"Jenny\")" "(*1 \"Yair\")" "(one-of \"Yair\" \"Oren\")" "((max-length 6) \"Yair Iny\")" "((max-length 6) \"Yair\")" "(max-length 6)" "(parse-file (clojure.java.io/resource \"test-bpv-files/single-registration.csv\"))" "(slurp *1)" "(clojure.java.io/resource \"test-bpv-files/single-registration.csv\")" "(require 'clojure.java.io)" "(require 'java.io)" "(java.io/resource \"hello\")" "(resource )" "(select bpv-file)" "(delete bpv-file)" "(select bpv-file)" "(insert bpv-file (values {:file-id \"0111\" :file-name \"YairRulez.csv\" :file-type :payer-registration :interface-spec-ver \"1.0.0\" :data-generated-time (java.util.Date.) :total-data-records 1 :result-code 1001}))" "(dry-run (insert bpv-file (values {:file-type :payer-registration})))" "(dry-run (insert bpv-file {:file-type :payer-registration}))" "(dry-run (insert bpv-file (values {:file-type \"Yair\"})))" "(dry-run (insert bpv-file (values {:file-type :payer-registration})))" "(dry-run (insert bpv-file {:file-type :payer-registration}))" "(update-in {} [:yair] count)" "(update-in {} [:yair] ->SNAKE_CASE)" "(clojure.string/upper-case (name :yair))" "(clojure.string/upper-case :yair)" "(clojure.string/upper-case \"yair\")" "(require 'clojure.string)" "(dry-run (select bpv-payer-activation (with bpv-file)))" "(select bpv-payer-activation (with bpv-file))" "(select bpv-payer-activation)" "(select bpv-file)" "(dry-run (select bpv-file))" "(select bpv-file)" "(->CamelCase :bpv-file)" "(->CamelCase :BPVFile)" "(->CamelCase :BPV_File)" "(select bpv-file)" "(use 'payreq.db)" "(+ 1 2)" "(start-server-and-repl)" "(pprint (test-one 1))" "(pprint (test-all))" "(extract-ids (first (get-in (test-all) [:body :users] (test-all))) :users)" "(first (get-in (test-all) [:body :users] (test-all)))" "(get-in (test-all) [:body :users] (test-all))" "(get-in [:body :users] (test-all))" "(test-all)" "(count (get-in *1 [:body :users]))" "(pprint (test-all))" "(pprint (test-delete 3))" "(pprint (test-all))" "(pprint (test-create {:username \"george\" :password \"poasasd\"}))" "(pprint (test-all))" "(pprint (test-one 1))" "(pprint (test-update 1 {:username \"yairiny\"}))" "(pprint (test-one 1))" "(pprint (test-update 1 {:username \"yairiny\"}))" "(pprint (update-one 1 {:username \"yairiny\"}))" "(pprint (test-one 1))" "(test-one 1)" "(pprint (test-one)) " "(pprint (-> (build-select d/users :users) k/select))" "(-> (build-select d/users :users) k/select)" "(build-select d/users :users)" "(test-all)" "(pprint *1)" "(test-all)" "(build-select d/users :users)" "@(resolve (symbol \"d/users\"))" "(resolve (symbol \"d/users\"))" "(k/select \"users\")" "(build-select d/users :users)" "(gen-get-all \"user\")" "(generate-all-routes* \"user\")" "(-> (build-select d/accounts :accounts) (k/select) (k/dry-run) (pprint))" "(k/select d/accounts (k/with d/transactions))" "(-> (build-select d/accounts :accounts) (k/select) (k/dry-run) (pprint))" "(-> (build-select d/users :users) (k/select) (k/dry-run) (pprint))" "(-> (build-select d/users :users) (k/select) (k/sql-only) (pprint))" "(-> (build-select d/users :users) (k/as-sql) (pprint))" "(-> (build-select d/users :users) (k/select) (pprint))" "(-> (build-select d/users :users) (k/select))" "(-> (build-select d/users :users) (k/as-sql))" "(-> (build-select d/users :users) k/sql-only)" "(build-select d/users :users)" "(pprint (k/select (build-select d/users :users)))" "(resolve (symbol \"d/accounts\"))" "#'(symbol \"d/accounts\")" "(symbol \"d/accounts\")" "(pprint (k/select (build-select d/users :users)))" "(k/select (build-select d/users :users))" "(build-select d/users :users)" "(k/select *1)" "    (reduce (fn [sel child-sym]
              (pprint child-sym)
              (-> sel (k/with d/accounts))) (k/select* d/users) [1])" "(build-select d/users :users)" "(k/select *1)" "(-> (k/select* d/users) (k/with d/accounts))" "(build-select d/users :users)" "(k/select *1)" "(build-select d/users)" "(map (comp name symbol) [:a :b])" "(map (comp symbol name) [:a :b])" "(map symbol [:a :b])" "(symbol :a)" "(pprint (test-all))" "(test-all)" "(-> (k/select* d/users ) (k/with* d/accounts (k/fields [:id])) k/select)" "(-> (k/select* d/users ) (k/with d/accounts (k/fields [:id])) k/select)" "(pprint *1)" "(-> (k/select* d/users ) (k/with d/accounts) k/select)" "(k/select *1)" "(-> (k/select* d/users ) (k/with d/accounts))" "(k/select* d/users )" "(keyword 'a)" "(data-routes {:uri \"/users\" :request-method :get})" "(apply -> [1 inc inc])" "(-> 1 inc inc)" "(k/where* {:id 1})" "(k/where {:id 1})" "(-> sel identity k/select)" "(-> sel (k/where {:id 1}) k/select)" "(k/select sel)" "(def sel (k/select* d/users))" "(k/select (k/select* d/users))" "((k/select* d/users))" "(k/select* d/users)" "(data-routes {:uri \"/users\" :request-method :get})" "(data-routes {:url \"/users\" :request-method :get})" "(System/exit 0)" "(map? [:a 1])" "(map? {:a 1})" "(pprint (k/select d/users))" "(t all)" "(name 'a)" "@(send-message {:from \"yiny@icm-consulting.com.au\" :to \"yair.iny@gmail.com\" :subject \"Test\" :body \"Hello World, this is a test.\"})" "@*1" "(send-message {:from \"yiny@icm-consulting.com.au\" :to \"yair.iny@gmail.com\" :subject \"Test\" :body \"Hello World, this is a test.\"})" "(start-server-and-repl)" "(+ 1 1)" "(map :constraints @event-store)" "(map :constraints @event-engine)" "@event-store" "(count @event-store)" "(:morrison @state)" "@state" "(count @event-store)" "@event-store" "@state" "(start-server-and-repl)" "@state" "(start-server-and-repl)" "(:boats @state)" "(advance-turn)" "(:boats @state)" "@state" "(random-boats 0.5)" "(random-boats 0.7)" "random-boats" "(start-server-and-repl)" ":cljs/quit" "(random-boats 0.1)" "(take 3 (repeatedly rand-boat))" "(random-boats 0.5)" "(rand-boat)" "(random-boats)" "(random-boats 0.5)" "(set [1 2 3])" "(hash-set [1 2 3])" "(advance-turn)" "(s/set [1 2 3])" "(set [1 2 3])" "(advance-turn)" "@state" "(start-server-and-repl)" ":cljs/quit" "(advance-turn)" "(start-server-and-repl)" "(action-boat b1 :sink)" "(:morrison @state)" "b1" "(def b1 (first (:boats @state)))" "(swap! state b/add-boats)" "@state" "(set [1 2 3])" "(action-boat b1 :sink)" "(:morrison @state)" "b1" "(def b1 (first (:boats @state)))" "(:boats @state)" "@state" "(:boats @state)" "(swap! state b/add-boats)" "state" "(random-boats 0.6)" "(random-boats 0.1)" "(map random-boats (range 0 1 0.05))" "(random-boat)" "(apply str (rest (str 1555)))" "(rest (str 1555))" "(str 1555)" "(str 6)" "(take 10 (repeatedly breakdown))" "(breakdown)" "(rand-countries)" "(s/difference #{1 2} #{2 4})" "(s/difference)" "(clojure.set/difference #{1 2} #{2 3})" "(conj #{1} 2)" "(rand-int 3)" "(rand-nth countries)" "(start-server-and-repl)" "(map deaths (range 0 1 0.05))" "(deaths 0.9)" "(deaths 2)" "(deaths 0)" "(start-server-and-repl)" "(:morrison @state)" "(:turn @state)" "(count (deref e/event-store))" "(map :constraints (deref e/event-store))" "(deref e/event-store)" "(pprint 1)" "(count (deref e/event-store))")